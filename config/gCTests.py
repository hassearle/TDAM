'''
    author:    Ash Searle    kss0024@auburn.edu
    created:   12/27/19
    updated:   7/5/20
    
    purpose:   validate the integrity of a STL file
'''

import unittest
import sys
import re
import ieeeConverter
import targetPrinter as p

class V3DPTestCases(unittest.TestCase):
	GCODE_PATH = ""
	GCODE_INPUT = ""
	SKIP_TEST = None
	TEMP_HEADER1 = 'M104 S(\d+)'
	TEMP_HEADER2 = 'M109 S(\d+)'
	BED_TEMP_HEADER1 = 'M140 S(\d+)'
	BED_TEMP_HEADER2 = 'M190 S(\d+)'
	SLICER_MATTER_SLICE = 'Generated with MatterSlice'
	SLICER_SLIC3R = 'generated by Slic3r'
	FAN_HEADER = 'M106'
	LAYER_HEIGHT_HEADER1 = 'G1 Z(-*\d+\.*\d*) *F*\d*\.*\d*\nG1 E'
	LAYER_HEIGHT_HEADER2 = 'G1 Z(-*\d+\.*\d*) *F*\d*\.*\d*\n'
	DIGITS = '(\d+\.\d+|\d+)'
	INFILL_HEADER1 = '; infillPercent = (-*\d+\.*\d*)'
	INFILL_HEADER2 = '; fill_density = (-*\d+\.*\d*)%'
	X_SIZE_HEADER = 'G1 X(-*\d+\.*\d*)'
	Y_SIZE_HEADER = 'G1 X*\d*\.*\d* *[Y](-*\d+.\d+|\d+)'
	Z_SIZE_HEADER = 'G1 *X*\d* *Y*\d* Z(-*\d+\.*\d+)'
	TEMP_VAR = p.TEMP_VAR
	MAX_TEMP_VAR = p.MAX_TEMP_VAR
	BED_TEMP_VAR = p.BED_TEMP_VAR
	MAX_BED_TEMP_VAR = p.MAX_BED_TEMP_VAR
	LAYER_HEIGHT = p.LAYER_HEIGHT
	INFILL_VAR = p.INFILL_VAR
	MAX_INFILL_VAR = p.MAX_INFILL_VAR
	MIN_INFILL_VAR = p.MIN_INFILL_VAR
	MAX_X_SIZE = p.MAX_X_SIZE
	MIN_X_SIZE = p.MIN_X_SIZE
	MAX_Y_SIZE = p.MAX_Y_SIZE
	MIN_Y_SIZE = p.MIN_Y_SIZE
	MAX_Z_SIZE = p.MAX_Z_SIZE
	MIN_Z_SIZE = p.MIN_Z_SIZE

	@classmethod
	def setUpClass(cls):
		if ".gcode" in cls.GCODE_PATH:
			cls.SKIP_TEST = False
			with open(cls.GCODE_PATH, 'r') as f:
				cls.GCODE_INPUT = f.read()
		else:
			cls.SKIP_TEST = True

	def setUp(self):
		if self.SKIP_TEST == True:
			self.skipTest("Not G-Code file")

	def test100_900_maxTemp(self):
		expectedResult = True
		actualResult = False

		m = re.findall(self.TEMP_HEADER1, self.GCODE_INPUT)
		for element in m:
			current = float(element)
			if current > self.MAX_TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_100_maxTemp(self):
	# 	expectedResult = True
	# 	actualResult = False

	# 	m = re.findall(self.TEMP_HEADER1, self.GCODE_INPUT)
	# 	for index, element in enumerate(m):
	# 		i = re.search(self.TEMP_DIGITS, element)
	# 		current = float(i.group(0))
	# 		if current < self.MAX_TEMP_VAR:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break
	# 	self.assertEqual(expectedResult, actualResult)

	def test100_901_maxTemp(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.TEMP_HEADER2, self.GCODE_INPUT)
		for element in m:
			current = float(element)
			if current > self.MAX_TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_101_maxTemp(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.TEMP_HEADER2, self.GCODE_INPUT)
	# 	for index, element in enumerate(m):
	# 		i = re.search(self.TEMP_DIGITS, element)
	# 		current = float(i.group(0))
	# 		if current < self.MAX_TEMP_VAR:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break
	# 	self.assertEqual(expectedResult, actualResult)

	def test100_910_temp(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.TEMP_HEADER1, self.GCODE_INPUT)
		for element in m:
			current = float(element)
			if current != 0 and current != self.TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") != value(" + str(self.TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_110_temp(self):
		# 	expectedResult = True
		# 	actualResult = False
			
		# 	m = re.findall(self.TEMP_HEADER1, self.GCODE_INPUT)
		# 	for index, element in enumerate(m):
		# 		i = re.search(self.TEMP_DIGITS, element)
		# 		current = float(i.group(0))
		# 		if current == 0 or current == self.TEMP_VAR:
		# 			actualResult = True
		# 		else:
		# 			actualResult = False
		# 			break
		# 	self.assertEqual(expectedResult, actualResult)

	def test100_911_temp(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.TEMP_HEADER2, self.GCODE_INPUT)
		for element in m:
			current = float(element)
			if current != 0 and current != self.TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") != value(" + str(self.TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_111_temp(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.TEMP_HEADER2, self.GCODE_INPUT)
	# 	for index, element in enumerate(m):
	# 		i = re.search(self.TEMP_DIGITS, element)
	# 		current = float(i.group(0))
	# 		if current == 0 or current == self.TEMP_VAR:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break
	# 	self.assertEqual(expectedResult, actualResult)

	def test100_920_bedTemp(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.BED_TEMP_HEADER1, self.GCODE_INPUT)
		if len(m) == 0:
			actualResult = True
		else:
			for element in m:
				current = float(element)
				if current != 0 and current != self.BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") != value(" + str(self.BED_TEMP_VAR) + ")"
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_120_bedTemp(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.BED_TEMP_HEADER1, self.GCODE_INPUT)
	# 	if len(m) == 0:
	# 		actualResult = True
	# 	else:
	# 		for index, element in enumerate(m):
	# 			current = float(element)
	# 			if current == 0 or current == self.BED_TEMP_VAR:
	# 				actualResult = True
	# 			else:
	# 				actualResult = False
	# 				break
	# 	self.assertEqual(expectedResult, actualResult)

	def test100_921_bedTemp(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.BED_TEMP_HEADER2, self.GCODE_INPUT)
		if len(m) == 0:
			actualResult = True
		else:
			for element in m:
				current = float(element)
				if current != 0 and current != self.BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") != value(" + str(self.BED_TEMP_VAR) + ")"
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_121_bedTemp(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.BED_TEMP_HEADER2, self.GCODE_INPUT)
	# 	if len(m) == 0:
	# 		actualResult = True
	# 	else:
	# 		for index, element in enumerate(m):
	# 			current = float(element)
	# 			if current == 0 or current == self.BED_TEMP_VAR:
	# 				actualResult = True
	# 			else:
	# 				actualResult = False
	# 				break
	# 	self.assertEqual(expectedResult, actualResult)

	def test100_930_bedTempMax(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.BED_TEMP_HEADER1, self.GCODE_INPUT)
		if len(m) == 0:
			actualResult = True
		else:
			for element in m:
				current = float(element)
				if current > self.MAX_BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_BED_TEMP_VAR) + ")" 
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_130_bedTempMax(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.BED_TEMP_HEADER1, self.GCODE_INPUT)
	# 	if len(m) == 0:
	# 		actualResult = True
	# 	else:
	# 		for index, element in enumerate(m):
	# 			current = float(element)
	# 			if current < self.MAX_BED_TEMP_VAR:
	# 				actualResult = True
	# 			else:
	# 				actualResult = False
	# 				break
	# 	self.assertEqual(expectedResult, actualResult)

	def test100_931_bedTempMax(self):
		expectedResult = True
		actualResult = False
		
		m = re.findall(self.BED_TEMP_HEADER2, self.GCODE_INPUT)
		if len(m) == 0:
			actualResult = True
		else:
			for element in m:
				current = float(element)
				if current > self.MAX_BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_BED_TEMP_VAR) + ")" 
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test100_131_bedTempMax(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.BED_TEMP_HEADER2, self.GCODE_INPUT)
	# 	if len(m) == 0:
	# 		actualResult = True
	# 	else:
	# 		for index, element in enumerate(m):
	# 			current = float(element)
	# 			if current < self.MAX_BED_TEMP_VAR:
	# 				actualResult = True
	# 			else:
	# 				actualResult = False
	# 				break
	# 	self.assertEqual(expectedResult, actualResult)

	def test200_900_fanNeverEngaged(self):
		expectedResult = True
		actualResult = False
		
		m = re.search(self.FAN_HEADER, self.GCODE_INPUT)
		actualResult = True if m != None else "fan never engaged"
		self.assertEqual(expectedResult, actualResult)

	# def test200_100_fanNeverEngaged(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.search(self.FAN_HEADER, self.GCODE_INPUT)
	# 	actualResult = False if m == None else True
	# 	self.assertEqual(expectedResult, actualResult)

	def test300_900_layerHeight(self):
		expectedResult = True
		actualResult = False
		
		header = ''
		skip = False
		if self.SLICER_MATTER_SLICE in self.GCODE_INPUT:
			header = self.LAYER_HEIGHT_HEADER1
		elif self.SLICER_SLIC3R in self.GCODE_INPUT:
			header = self.LAYER_HEIGHT_HEADER2
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"
			skip = True

		if skip == False:
			m = re.findall(header, self.GCODE_INPUT)
			mLength = len(m)
			previous = next_ = None
			for index, element in enumerate(m):
				current = float(element)
				if index < 1:
					# skip because 1st layer height may be different
					continue
					# previous previous = float(m[index -1])
					# diff1 = round(current - previous, 3)
					# if diff1 != 0.0 and diff1 != self.LAYER_HEIGHT:
					# 	print("\none")
					# 	print("previous: " + str(previous))
					# 	actualResult = "layer height error: value(" + str(current) + ") != value(" + str(self.LAYER_HEIGHT) + ")"
					# 	break= float(m[index -1])
					# diff1 = round(current - previous, 3)
					# if diff1 != 0.0 and diff1 != self.LAYER_HEIGHT:
					# 	print("\none")
					# 	print("previous: " + str(previous))
					# 	actualResult = "layer height error: value(" + str(current) + ") != value(" + str(self.LAYER_HEIGHT) + ")"
					# 	break

				if index < (mLength -1):
					next_ = float(m[index + 1])
					diff2 = round(next_ - current, 3)
					if diff2 != 0.0 and diff2 != self.LAYER_HEIGHT:
						actualResult = "layer height error: value(" + str(next_) + ") != value(" + str(self.LAYER_HEIGHT) + ")"
						break
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	# def test300_100_layerHeight(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	header = ''
	# 	skip = False
	# 	if self.SLICER_MATTER_SLICE in self.GCODE_INPUT:
	# 		header = self.LAYER_HEIGHT_HEADER1
	# 	elif self.SLICER_SLIC3R in self.GCODE_INPUT:
	# 		header = self.LAYER_HEIGHT_HEADER2
	# 	else:
	# 		actualResult = "Unknown slicer. Unable to determine infill density"
	# 		skip = True

	# 	if skip == False:
	# 		m = re.findall(header, self.GCODE_INPUT)
	# 		mLength = len(m)
	# 		previous = next_ = None
	# 		for index, element in enumerate(m):
	# 			current = float(element)
	# 			if index < 1:
	# 				# skip because 1st layer height may be different
	# 				continue
	# 			if index < (mLength -1):
	# 				next_ = float(m[index + 1])
	# 				diff2 = round(next_ - current, 3)
	# 				if diff2 == 0.0 or diff2 == self.LAYER_HEIGHT:
	# 					actualResult = True
	# 				else:
	# 					actualResult = False
	# 					break
	# 	self.assertEqual(expectedResult, actualResult)

	# def test400_100_feedRate(self):
	# 	pass
		#112.5

	# '[G][1] [X]([0-9]+|[0-9]+.[0-9]+) ([E][0-9]+.[0-9]+ [F][0-9]+|[E][0-9]+.[0-9]+)'
	# '[G][1] [X]([0-9]+|[0-9]+.[0-9]+) [Y]([0-9]+|[0-9]+.[0-9]+) ([E][0-9]+.[0-9]+ [F][0-9]+|[E][0-9]+.[0-9]+)'

	def test500_900_infill(self):
		expectedResult = True
		actualResult = False
		
		m = re.search(self.SLICER_MATTER_SLICE, self.GCODE_INPUT)
		n = re.search(self.SLICER_SLIC3R, self.GCODE_INPUT)

		if m != None:
			o = re.search(self.INFILL_HEADER1, self.GCODE_INPUT)
			infill1 = float(o.group(1))
			if infill1 != self.INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill1) + ") != value(" + str(self.INFILL_VAR) + ")"
			else: 
				actualResult = True
		elif n != None:
			p = re.search(self.INFILL_HEADER2, self.GCODE_INPUT)
			infill2 = float(p.group(1))
			if infill2 != self.INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill2) + ") != value(" + str(self.INFILL_VAR) + ")"
			else:
				actualResult = True
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"

		self.assertEqual(expectedResult, actualResult)

		# expectedResult = True
		# actualResult = False

		# # with open(self.GCODE_INPUT, 'r') as f:
		# 	# 	self.GCODE_INPUT = f.read()
		# 	# m = re.findall(self.INFILL, self.GCODE_INPUT)
		# 	# n = []
		# 	# for element in m:
		# 	# 	n.append(float(element[0]))
		# 	# xxDiff = n[6] - n[5]
		# 	# print(xxDiff)
		# 	# n.sort()
		# 	# highestX = n[-1]
		# 	# lowestX = n[0]
		# 	# print(highestX)
		# 	# print(lowestX)
		# 	# xDiff = highestX - lowestX
		# 	# print(xDiff)
		# 	# xxxDiff = xDiff / xxDiff
		# 	# print(xxxDiff)
		# infill = []
		# tempInfillList = ""
		# skipHeader = 'LAYER_HEIGHT'
		# infillHeader = 'TYPE:FILL'
		# stopHeader = '; '
		# skip = False
		# cont = False
		# with open(self.GCODE_INPUT, 'r') as f:
		# 	for index, line in enumerate(f):
		# 		if skipHeader in line:
		# 			skip = True
		# 			f.readline()
		# 			# print("two " + str(index) + " " + f.readline())
		# 		elif infillHeader in line:
		# 			cont = True
		# 			# print("three " + str(index) + " " + f.readline())
		# 			while cont == True:
		# 				nextLine = f.readline()
		# 				nextLine = nextLine

		# 				if stopHeader in nextLine:
		# 					# print("four " + str(index) + " " + f.readline())
		# 					cont = False
		# 					infill.append(tempInfillList)
		# 					tempInfillList = ""
		# 					break
		# 				else:
		# 					tempInfillList += nextLine
		# 					# print("five " + str(index) + " " + nextLine)

		# # for index, element in enumerate(infill):
		# 	# print(index)
		# 	# print("[ " + element + "]")

		# avgInfill = []
		# for element in infill:
		# # 	for element_ in list_:
		# 	m = re.findall(self.INFILL, element)
		# 	# print("[ " + str(m) + "]")
		# 	n = []
		# 	index_ = -1
		# 	for index, item in enumerate(m):
		# 		index_ = index
		# 		n.append(float(item[0]))
		# 	if len(n) == 0: continue
		# 	if n[0] > n[3]: spaceBetweenX_1 = n[0] - n[3]
		# 	else: spaceBetweenX_1 = n[3] - n[0]
			
		# 	if n[-1] > n[-4]: spaceBetweenX_2 = n[-1] - n[-4]
		# 	else: spaceBetweenX_2 = n[-4] - n[-1]

		# 	if spaceBetweenX_1 > spaceBetweenX_2:
		# 		spaceBetweenX = spaceBetweenX_1
		# 	else:
		# 		spaceBetweenX = spaceBetweenX_2


		# 	print("space b/w x: " + str(spaceBetweenX))
			
		# 	n.sort()
		# 	highestX = n[-1]
		# 	lowestX = n[0]
		# 	print("highest X: " + str(highestX))
		# 	print("lowest X: " + str(lowestX))

		# 	totalXSpace = highestX - lowestX
		# 	# totalXSpace = index * spaceBetweenX
		# 	print("total X Space: " + str(totalXSpace))

		# 	# percentNotInfill = totalXSpace / spaceBetweenX
		# 	# percentInfill = totalXSpace / percentNotInfill
		# 	percentInfill = totalXSpace / spaceBetweenX
		# 	print("percent infill: " + str(percentInfill))
		# 	if percentInfill <= 100:
		# 		avgInfill.append(percentInfill)
			
		# 	print(index_)
		# 	# print(element)

		# # print(statistics.mean(avgInfill))
		# print("\n")

	# def test500_100_infill(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.search(self.SLICER_MATTER_SLICE, self.GCODE_INPUT)
	# 	n = re.search(self.SLICER_SLIC3R, self.GCODE_INPUT)

	# 	if m != None:
	# 		o = re.search(self.INFILL_HEADER1, self.GCODE_INPUT)
	# 		infill1 = float(o.group(1))
	# 		if infill1 == self.INFILL_VAR:
	# 			actualResult = True
	# 		else: 
	# 			actualResult = False
	# 	elif n != None:
	# 		p = re.search(self.INFILL_HEADER2, self.GCODE_INPUT)
	# 		infill2 = float(p.group(1))
	# 		if infill2 == self.INFILL_VAR:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 	else:
	# 		actualResult = "Unknown slicer. Unable to determine infill density"

	# 	self.assertEqual(expectedResult, actualResult)

	def test500_910_infillMax(self):
		expectedResult = True
		actualResult = False
		
		m = re.search(self.SLICER_MATTER_SLICE, self.GCODE_INPUT)
		n = re.search(self.SLICER_SLIC3R, self.GCODE_INPUT)

		if m != None:
			o = re.search(self.INFILL_HEADER1, self.GCODE_INPUT)
			infill1 = float(o.group(1))
			if infill1 > self.MAX_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill1) + ") > value(" + str(self.MAX_INFILL_VAR) + ")"
			else: 
				actualResult = True
		elif n != None:
			p = re.search(self.INFILL_HEADER2, self.GCODE_INPUT)
			infill2 = float(p.group(1))
			if infill2 > self.MAX_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill2) + ") > value(" + str(self.MAX_INFILL_VAR) + ")"
			else:
				actualResult = True
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"

		self.assertEqual(expectedResult, actualResult)

	# def test500_110_infillMax(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.search(self.SLICER_MATTER_SLICE, self.GCODE_INPUT)
	# 	n = re.search(self.SLICER_SLIC3R, self.GCODE_INPUT)

	# 	if m != None:
	# 		o = re.search(self.INFILL_HEADER1, self.GCODE_INPUT)
	# 		infill1 = float(o.group(1))
	# 		if infill1 < self.MAX_INFILL_VAR:
	# 			actualResult = True
	# 		else: 
	# 			actualResult = False
	# 	elif n != None:
	# 		p = re.search(self.INFILL_HEADER2, self.GCODE_INPUT)
	# 		infill2 = float(p.group(1))
	# 		if infill2 < self.MAX_INFILL_VAR:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 	else:
	# 		actualResult = "Unknown slicer. Unable to determine infill density"

	# 	self.assertEqual(expectedResult, actualResult)

	def test500_920_infillMin(self):
		expectedResult = True
		actualResult = False
		
		m = re.search(self.SLICER_MATTER_SLICE, self.GCODE_INPUT)
		n = re.search(self.SLICER_SLIC3R, self.GCODE_INPUT)

		if m != None:
			o = re.search(self.INFILL_HEADER1, self.GCODE_INPUT)
			infill1 = float(o.group(1))
			if infill1 < self.MIN_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill1) + ") < value(" + str(self.MIN_INFILL_VAR) + ")"
			else: 
				actualResult = True
		elif n != None:
			p = re.search(self.INFILL_HEADER2, self.GCODE_INPUT)
			infill2 = float(p.group(1))
			if infill2 < self.MIN_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill2) + ") < value(" + str(self.MIN_INFILL_VAR) + ")"
			else:
				actualResult = True
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"

		self.assertEqual(expectedResult, actualResult)

	# def test500_120_infillMin(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.search(self.SLICER_MATTER_SLICE, self.GCODE_INPUT)
	# 	n = re.search(self.SLICER_SLIC3R, self.GCODE_INPUT)

	# 	if m != None:
	# 		o = re.search(self.INFILL_HEADER1, self.GCODE_INPUT)
	# 		infill1 = float(o.group(1))
	# 		if infill1 > self.MIN_INFILL_VAR:
	# 			actualResult = True
	# 		else: 
	# 			actualResult = False
	# 	elif n != None:
	# 		p = re.search(self.INFILL_HEADER2, self.GCODE_INPUT)
	# 		infill2 = float(p.group(1))
	# 		if infill2 > self.MIN_INFILL_VAR:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 	else:
	# 		actualResult = "Unknown slicer. Unable to determine infill density"

	# 	self.assertEqual(expectedResult, actualResult)

	# if wrong type:fill continue and skip
	# if type:fill: save to list
	# if ; in line stop saving to list

	def test600_900_exceedsMaxXSize(self):
		expectedResult = False
		actualResult = True
		
		m = re.findall(self.X_SIZE_HEADER, self.GCODE_INPUT)
		elementX = None
		for index, element in enumerate(m):
			elementX = element
			if float(element) > self.MAX_X_SIZE:
				actualResult = " X value(" + str(elementX) + ") > X-axis bounds(" + str(self.MAX_X_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	# def test600_100_exceedsMaxXSize(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.X_SIZE_HEADER, self.GCODE_INPUT)
	# 	elementX = None
	# 	for index, element in enumerate(m):
	# 		elementX = element
	# 		if float(element) < self.MAX_X_SIZE:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break

	# 	self.assertEqual(expectedResult, actualResult)

	def test600_910_exceedsMinXSize(self):
		expectedResult = False
		actualResult = True		

		m = re.findall(self.X_SIZE_HEADER, self.GCODE_INPUT)
		elementX = None
		for index, element in enumerate(m):
			elementX = element
			if float(element) < self.MIN_X_SIZE:
				if index == 0: continue
				actualResult = " X value(" + str(elementX) + ") < X-axis bounds(" + str(self.MIN_X_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	# def test600_110_exceedsMinXSize(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.X_SIZE_HEADER, self.GCODE_INPUT)
	# 	elementX = None
	# 	for index, element in enumerate(m):
	# 		elementX = element
	# 		if float(element) > self.MIN_X_SIZE:
	# 			actualResult = True
	# 		else:
	# 			if index == 0: continue
	# 			actualResult = false


	# 	self.assertEqual(expectedResult, actualResult)

	def test600_920_exceedsMaxYSize(self):
		expectedResult = False
		actualResult = True

		m = re.findall(self.Y_SIZE_HEADER, self.GCODE_INPUT)
		elementY = None
		for index, element in enumerate(m):
			elementY = element
			if float(element) > self.MAX_Y_SIZE:
				actualResult = " Y value(" + str(elementY) + ") > Y-axis bounds(" + str(self.MAX_Y_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	# def test600_120_exceedsMaxYSize(self):
	# 	expectedResult = True
	# 	actualResult = False

	# 	m = re.findall(self.Y_SIZE_HEADER, self.GCODE_INPUT)
	# 	elementY = None
	# 	for index, element in enumerate(m):
	# 		elementY = element
	# 		if float(element) <= self.MAX_Y_SIZE:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break

	# 	self.assertEqual(expectedResult, actualResult)

	def test600_930_exceedsMinYSize(self):
		expectedResult = False
		actualResult = True
		
		m = re.findall(self.Y_SIZE_HEADER, self.GCODE_INPUT)
		elementY = None
		for index, element in enumerate(m):
			elementY = element
			if float(element) < self.MIN_Y_SIZE:
				if index == 0: continue
				actualResult = " Y value(" + str(elementY) + ") < Y-axis bounds(" + str(self.MIN_Y_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False
		self.assertEqual(expectedResult, actualResult)

	# def test600_130_exceedsMinYSize(self):
	# 	expectedResult = True
	# 	actualResult = False
		
	# 	m = re.findall(self.Y_SIZE_HEADER, self.GCODE_INPUT)
	# 	elementY = None
	# 	for index, element in enumerate(m):
	# 		elementY = element
	# 		if float(element) >= self.MIN_Y_SIZE:
	# 			actualResult = True
	# 		else:
	# 			if index == 0: continue
	# 			actualResult = False
	# 			break
	# 	self.assertEqual(expectedResult, actualResult)

	def test600_940_exceedsMaxZSize(self):
		expectedResult = False
		actualResult = True

		m = re.findall(self.Z_SIZE_HEADER, self.GCODE_INPUT)
		elementZ = None
		for index, element in enumerate(m):
			elementZ = element
			if float(element) > self.MAX_Z_SIZE:
				actualResult = "Z value(" + str(elementZ) + ") > Z-axis bounds(" + str(self.MAX_Z_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	# def test600_140_exceedsMaxZSize(self):
	# 	expectedResult = True
	# 	actualResult = False

	# 	m = re.findall(self.Z_SIZE_HEADER, self.GCODE_INPUT)
	# 	elementZ = None
	# 	for index, element in enumerate(m):
	# 		elementZ = element
	# 		if float(element) < self.MAX_Z_SIZE:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break

	# 	self.assertEqual(expectedResult, actualResult)

	def test600_950_exceedsMinZSize(self):
		expectedResult = False
		actualResult = True

		m = re.findall(self.Z_SIZE_HEADER, self.GCODE_INPUT)
		elementZ = None
		for index, element in enumerate(m):
			elementZ = element
			if float(element) < self.MIN_Z_SIZE:
				if index == 0: continue
				actualResult = "Z value(" + str(elementZ) + ") < Z-axis bounds(" + str(self.MIN_Z_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	# def test600_150_exceedsMinZSize(self):
	# 	expectedResult = True
	# 	actualResult = False

	# 	m = re.findall(self.Z_SIZE_HEADER, self.GCODE_INPUT)
	# 	elementZ = None
	# 	for index, element in enumerate(m):
	# 		elementZ = element
	# 		if float(element) > self.MIN_Z_SIZE:
	# 			actualResult = True
	# 		else:
	# 			actualResult = False
	# 			break

	# 	self.assertEqual(expectedResult, actualResult)

class CMBTestCases(unittest.TestCase):
	CMB_PATH = ""
	CMB_INPUT = ""
	SKIP_TEST = None

	CMB_MAX_X_SIZE = p.CMB_MAX_X_SIZE
	CMB_MAX_Y_SIZE = p.CMB_MAX_Y_SIZE
	CMB_MAX_Z_SIZE = p.CMB_MAX_Z_SIZE

	expectedResult = False
	actualResult = True

	@classmethod
	def setUpClass(cls):
		if ".cmb" in cls.CMB_PATH:
			cls.SKIP_TEST = False
			with open(cls.CMB_PATH, 'rb') as f:
				cls.CMB_INPUT = f.read().hex()
		else:
			cls.SKIP_TEST = True

	def setUp(self):
		if self.SKIP_TEST == True:
			self.skipTest("Not CMB file")
		self.expectedResult = False
		self.actualResult = True

	def test700_900_cmb_exceedsMaxXSize(self):
		index_ = 0
		part_max_X = ""
		temp = ""
		hexList = []
		for line in self.CMB_INPUT:
			for element in line:
				temp += element
				if (index_ + 1) % 2 == 0:
					hexList.append(temp)
					temp = ""
				index_ += 1
				if index_ == 200:
					break

		for index, value in enumerate(hexList):
			if index >= 50 and index <= 53:
				part_max_X = value + part_max_X
			elif index > 53:
				break
			index += 1

		floatMaxX_in = ieeeConverter.hex2Float(part_max_X)
		floatMaxX_mm = floatMaxX_in / 0.0393700787
		if floatMaxX_mm > self.CMB_MAX_X_SIZE:
			self.actualResult = " X value(" + str(floatMaxX_mm) + ") > X-axis bounds(" + str(self.CMB_MAX_X_SIZE) + ")"
		else:
			self.actualResult = False

		self.assertEqual(self.expectedResult, self.actualResult)

	# def test700_100_cmb_exceedsMaxXSize(self):
	# 	index_ = 0
	# 	part_max_X = ""
	# 	temp = ""
	# 	hexList = []
	# 	for line in self.CMB_INPUT:
	# 		for element in line:
	# 			temp += element
	# 			if (index_ + 1) % 2 == 0:
	# 				hexList.append(temp)
	# 				temp = ""
	# 			index_ += 1
	# 			if index_ == 200:
	# 				break

	# 	for index, value in enumerate(hexList):
	# 		if index >= 50 and index <= 53:
	# 			part_max_X = value + part_max_X
	# 		elif index > 53:
	# 			break
	# 		index += 1

	# 	floatMaxX_in = ieeeConverter.hex2Float(part_max_X)
	# 	floatMaxX_mm = floatMaxX_in / 0.0393700787
	# 	if floatMaxX_mm < self.CMB_MAX_X_SIZE:
	# 		self.actualResult = False
	# 	else:
	# 		self.actualResult = True

	# 	self.assertEqual(self.expectedResult, self.actualResult)

	def test700_910_cmb_exceedsMaxYSize(self):
		index_ = 0
		part_max_Y = ""
		temp = ""
		hexList = []
		for line in self.CMB_INPUT:
			for element in line:
				temp += element
				if (index_ + 1) % 2 == 0:
					hexList.append(temp)
					temp = ""
				index_ += 1
				if index_ == 200:
					break

		for index, value in enumerate(hexList):
			if index >= 54 and index <= 57:
				part_max_Y = value + part_max_Y
			elif index > 58:
				break
			index += 1

		floatMaxY_in = ieeeConverter.hex2Float(part_max_Y)
		floatMaxY_mm = floatMaxY_in / 0.0393700787
		if floatMaxY_mm > self.CMB_MAX_Y_SIZE:
			self.actualResult = " Y value(" + str(floatMaxY_mm) + ") > Y-axis bounds(" + str(self.CMB_MAX_Y_SIZE) + ")"
		else:
			self.actualResult = False

		self.assertEqual(self.expectedResult, self.actualResult)

	# def test700_110_cmb_exceedsMaxYSize(self):
	# 	index_ = 0
	# 	part_max_Y = ""
	# 	temp = ""
	# 	hexList = []
	# 	for line in self.CMB_INPUT:
	# 		for element in line:
	# 			temp += element
	# 			if (index_ + 1) % 2 == 0:
	# 				hexList.append(temp)
	# 				temp = ""
	# 			index_ += 1
	# 			if index_ == 200:
	# 				break

	# 	for index, value in enumerate(hexList):
	# 		if index >= 54 and index <= 57:
	# 			part_max_Y = value + part_max_Y
	# 		elif index > 58:
	# 			break
	# 		index += 1

	# 	floatMaxY_in = ieeeConverter.hex2Float(part_max_Y)
	# 	floatMaxY_mm = floatMaxY_in / 0.0393700787
	# 	if floatMaxY_mm < self.CMB_MAX_Y_SIZE:
	# 		self.actualResult = False
	# 	else:
	# 		self.actualResult = True

	# 	self.assertEqual(self.expectedResult, self.actualResult)

	def test700_920_cmb_exceedsMaxZSize(self):
		index_ = 0
		part_max_Z = ""
		temp = ""
		hexList = []
		for line in self.CMB_INPUT:
			for element in line:
				temp += element
				if (index_ + 1) % 2 == 0:
					hexList.append(temp)
					temp = ""
				index_ += 1
				if index_ == 200:
					break

		for index, value in enumerate(hexList):
			if index >= 58 and index <= 61:
				part_max_Z = value + part_max_Z
			elif index > 62:
				break
			index += 1

		floatMaxZ_in = ieeeConverter.hex2Float(part_max_Z)
		floatMaxZ_mm = floatMaxZ_in / 0.0393700787
		floatMaxZ_mm = round(floatMaxZ_mm)
		if floatMaxZ_mm > self.CMB_MAX_Z_SIZE:
			self.actualResult = " Z value(" + str(floatMaxZ_mm) + ") > Z-axis bounds(" + str(self.CMB_MAX_Z_SIZE) + ")"
		else:
			self.actualResult = False

		self.assertEqual(self.expectedResult, self.actualResult)

	# def test700_120_cmb_exceedsMaxZSize(self):
	# 	index_ = 0
	# 	part_max_Z = ""
	# 	temp = ""
	# 	hexList = []
	# 	for line in self.CMB_INPUT:
	# 		for element in line:
	# 			temp += element
	# 			if (index_ + 1) % 2 == 0:
	# 				hexList.append(temp)
	# 				temp = ""
	# 			index_ += 1
	# 			if index_ == 200:
	# 				break

	# 	for index, value in enumerate(hexList):
	# 		if index >= 58 and index <= 61:
	# 			part_max_Z = value + part_max_Z
	# 		elif index > 62:
	# 			break
	# 		index += 1

	# 	floatMaxZ_in = ieeeConverter.hex2Float(part_max_Z)
	# 	floatMaxZ_mm = floatMaxZ_in / 0.0393700787
	# 	floatMaxZ_mm = round(floatMaxZ_mm)
	# 	if floatMaxZ_mm < self.CMB_MAX_Z_SIZE:
	# 		self.actualResult = False
	# 	else:
	# 		self.actualResult = True

	# 	self.assertEqual(self.expectedResult, self.actualResult)

if __name__ == '__main__':
	if len(sys.argv) > 1:
		filePath = sys.argv.pop()
		V3DPTestCases.GCODE_PATH = filePath
		CMBTestCases.CMB_PATH = filePath
		# print(V3DPTestCases.GCODE_INPUT)
	unittest.main()

