'''
    author:    Ash Searle    kss0024@auburn.edu
    created:   12/27/19
    updated:   1/14/20
    
    purpose:   validate the integrity of a STL file
'''

import unittest
import sys
import re
import ieeeConverter

class V3DPTestCases(unittest.TestCase):
	GCODE_INPUT = ""
	TEMP_HEADER1 = '(?<=M104)(.*)'
	TEMP_HEADER2 = '(?<=M109)(.*)'
	TEMP_DIGITS = '(?<=S)([0-9]+|[0])'
	TEMP_VAR = 210
	MAX_TEMP_VAR = 220
	BED_TEMP_HEADER1 = '[M][1][4][0] [S]([0-9]+)'
	BED_TEMP_HEADER2 = '[M][1][9][0] [S]([0-9]+)'
	BED_TEMP_VAR = 35
	MAX_BED_TEMP_VAR = 65
	LAYER_HEIGHT = 0.3
	SLICER_MATTER_SLICE = 'Generated with MatterSlice'
	SLICER_SLIC3R = 'generated by Slic3r'
	FAN_HEADER = '(?<=M106)(.*)'
	LAYER_HEIGHT_HEADER1 = 'G1 Z(-*\d+\.*\d*) *F*\d*\.*\d*\nG1 E'
	LAYER_HEIGHT_HEADER2 = 'G1 Z(-*\d+\.*\d*) *F*\d*\.*\d*\n'
	DIGITS = '(\d+\.\d+|\d+)'
	INFILL_HEADER1 = '; infillPercent = (-*\d+\.*\d*)'
	INFILL_HEADER2 = '; fill_density = (-*\d+\.*\d*)%'
	INFILL_VAR = 20.0
	MAX_INFILL_VAR = 100.0
	MIN_INFILL_VAR = 0.0
	# MAX_X_SIZE = 228.0
	# MIN_X_SIZE = 2.0
	MAX_X_SIZE = 200.0
	MIN_X_SIZE = 0.1
	X_SIZE_HEADER = 'G1 X(-*\d+\.*\d*)'
	# MAX_Y_SIZE = 254.0
	# MIN_Y_SIZE = 2.0
	MAX_Y_SIZE = 200.0
	MIN_Y_SIZE = 0.1
	Y_SIZE_HEADER = 'G1 X*\d*\.*\d* *[Y](-*\d+.\d+|\d+)'
	# MAX_Z_SIZE = 254.0
	# MIN_Z_SIZE = 2.0
	MAX_Z_SIZE = 200.0
	MIN_Z_SIZE = 0.1
	Z_SIZE_HEADER = 'G1 *X*\d* *Y*\d* Z(-*\d+\.*\d+)'

	def setUp(self):
		pass

	def test100_900_maxTemp(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.TEMP_HEADER1, gCodeInput)
		for index, element in enumerate(m):
			i = re.search(self.TEMP_DIGITS, element)
			current = float(i.group(0))
			if current > self.MAX_TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_901_maxTemp(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.TEMP_HEADER2, gCodeInput)
		for index, element in enumerate(m):
			i = re.search(self.TEMP_DIGITS, element)
			current = float(i.group(0))
			if current > self.MAX_TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_110_temp(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.TEMP_HEADER1, gCodeInput)
		for index, element in enumerate(m):
			i = re.search(self.TEMP_DIGITS, element)
			current = float(i.group(0))
			if current != 0 and current != self.TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") != value(" + str(self.TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_111_temp(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.TEMP_HEADER2, gCodeInput)
		for index, element in enumerate(m):
			i = re.search(self.TEMP_DIGITS, element)
			current = float(i.group(0))
			if current != 0 and current != self.TEMP_VAR:
				actualResult = "Extruder Temp Error: value(" + str(current) + ") != value(" + str(self.TEMP_VAR) + ")"
				break
			else:
				actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_120_bedTemp(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.BED_TEMP_HEADER1, gCodeInput)
		if len(m) == 0:
			actualResult = True
		else:
			for index, element in enumerate(m):
				current = float(element)
				if current != 0 and current != self.BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") != value(" + str(self.BED_TEMP_VAR) + ")"
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_121_bedTemp(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.BED_TEMP_HEADER2, gCodeInput)
		if len(m) == 0:
			actualResult = True
		else:
			for index, element in enumerate(m):
				current = float(element)
				if current != 0 and current != self.BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") != value(" + str(self.BED_TEMP_VAR) + ")"
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_930_bedTempMax(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.BED_TEMP_HEADER1, gCodeInput)
		if len(m) == 0:
			actualResult = True
		else:
			for index, element in enumerate(m):
				current = float(element)
				if current > self.MAX_BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_BED_TEMP_VAR) + ")" 
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test100_931_bedTempMax(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.findall(self.BED_TEMP_HEADER2, gCodeInput)
		if len(m) == 0:
			actualResult = True
		else:
			for index, element in enumerate(m):
				current = float(element)
				if current > self.MAX_BED_TEMP_VAR:
					actualResult = "Bed Temp Error: value(" + str(current) + ") > bounds(" + str(self.MAX_BED_TEMP_VAR) + ")" 
					break
				else:
					actualResult = True
		self.assertEqual(expectedResult, actualResult)

	def test200_900_fanNeverEngaged(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		m = re.search(self.FAN_HEADER, gCodeInput)
		actualResult = True if m != None else "fan never engaged"
		self.assertEqual(expectedResult, actualResult)

	def test300_100_layerHeight(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")
		header = ''
		skip = False
		if self.SLICER_MATTER_SLICE in gCodeInput:
			header = self.LAYER_HEIGHT_HEADER1
		elif self.SLICER_SLIC3R in gCodeInput:
			header = self.LAYER_HEIGHT_HEADER2
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"
			skip = True

		if skip == False:
			m = re.findall(header, gCodeInput)
			mLength = len(m)
			previous = next_ = None
			for index, element in enumerate(m):
				current = float(element)
				if index < 1:
					# skip because 1st layer height may be different
					continue
					# previous previous = float(m[index -1])
					# diff1 = round(current - previous, 3)
					# if diff1 != 0.0 and diff1 != self.LAYER_HEIGHT:
					# 	print("\none")
					# 	print("previous: " + str(previous))
					# 	actualResult = "layer height error: value(" + str(current) + ") != value(" + str(self.LAYER_HEIGHT) + ")"
					# 	break= float(m[index -1])
					# diff1 = round(current - previous, 3)
					# if diff1 != 0.0 and diff1 != self.LAYER_HEIGHT:
					# 	print("\none")
					# 	print("previous: " + str(previous))
					# 	actualResult = "layer height error: value(" + str(current) + ") != value(" + str(self.LAYER_HEIGHT) + ")"
					# 	break

				if index < (mLength -1):
					next_ = float(m[index + 1])
					diff2 = round(next_ - current, 3)
					if diff2 != 0.0 and diff2 != self.LAYER_HEIGHT:
						actualResult = "layer height error: value(" + str(next_) + ") != value(" + str(self.LAYER_HEIGHT) + ")"
						break
				actualResult = True
		self.assertEqual(expectedResult, actualResult)
	

	# def test400_100_feedRate(self):
	# 	pass
		#112.5

	# '[G][1] [X]([0-9]+|[0-9]+.[0-9]+) ([E][0-9]+.[0-9]+ [F][0-9]+|[E][0-9]+.[0-9]+)'
	# '[G][1] [X]([0-9]+|[0-9]+.[0-9]+) [Y]([0-9]+|[0-9]+.[0-9]+) ([E][0-9]+.[0-9]+ [F][0-9]+|[E][0-9]+.[0-9]+)'

	def test500_100_infill(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.search(self.SLICER_MATTER_SLICE, gCodeInput)
		n = re.search(self.SLICER_SLIC3R, gCodeInput)

		if m != None:
			o = re.search(self.INFILL_HEADER1, gCodeInput)
			infill1 = float(o.group(1))
			if infill1 != self.INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill1) + ") != value(" + str(self.INFILL_VAR) + ")"
			else: 
				actualResult = True
		elif n != None:
			p = re.search(self.INFILL_HEADER2, gCodeInput)
			infill2 = float(p.group(1))
			if infill2 != self.INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill2) + ") != value(" + str(self.INFILL_VAR) + ")"
			else:
				actualResult = True
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"

		self.assertEqual(expectedResult, actualResult)

		# expectedResult = True
		# actualResult = False

		# # with open(self.GCODE_INPUT, 'r') as f:
		# 	# 	gCodeInput = f.read()
		# 	# m = re.findall(self.INFILL, gCodeInput)
		# 	# n = []
		# 	# for element in m:
		# 	# 	n.append(float(element[0]))
		# 	# xxDiff = n[6] - n[5]
		# 	# print(xxDiff)
		# 	# n.sort()
		# 	# highestX = n[-1]
		# 	# lowestX = n[0]
		# 	# print(highestX)
		# 	# print(lowestX)
		# 	# xDiff = highestX - lowestX
		# 	# print(xDiff)
		# 	# xxxDiff = xDiff / xxDiff
		# 	# print(xxxDiff)
		# infill = []
		# tempInfillList = ""
		# skipHeader = 'LAYER_HEIGHT'
		# infillHeader = 'TYPE:FILL'
		# stopHeader = '; '
		# skip = False
		# cont = False
		# with open(self.GCODE_INPUT, 'r') as f:
		# 	for index, line in enumerate(f):
		# 		if skipHeader in line:
		# 			skip = True
		# 			f.readline()
		# 			# print("two " + str(index) + " " + f.readline())
		# 		elif infillHeader in line:
		# 			cont = True
		# 			# print("three " + str(index) + " " + f.readline())
		# 			while cont == True:
		# 				nextLine = f.readline()
		# 				nextLine = nextLine

		# 				if stopHeader in nextLine:
		# 					# print("four " + str(index) + " " + f.readline())
		# 					cont = False
		# 					infill.append(tempInfillList)
		# 					tempInfillList = ""
		# 					break
		# 				else:
		# 					tempInfillList += nextLine
		# 					# print("five " + str(index) + " " + nextLine)

		# # for index, element in enumerate(infill):
		# 	# print(index)
		# 	# print("[ " + element + "]")

		# avgInfill = []
		# for element in infill:
		# # 	for element_ in list_:
		# 	m = re.findall(self.INFILL, element)
		# 	# print("[ " + str(m) + "]")
		# 	n = []
		# 	index_ = -1
		# 	for index, item in enumerate(m):
		# 		index_ = index
		# 		n.append(float(item[0]))
		# 	if len(n) == 0: continue
		# 	if n[0] > n[3]: spaceBetweenX_1 = n[0] - n[3]
		# 	else: spaceBetweenX_1 = n[3] - n[0]
			
		# 	if n[-1] > n[-4]: spaceBetweenX_2 = n[-1] - n[-4]
		# 	else: spaceBetweenX_2 = n[-4] - n[-1]

		# 	if spaceBetweenX_1 > spaceBetweenX_2:
		# 		spaceBetweenX = spaceBetweenX_1
		# 	else:
		# 		spaceBetweenX = spaceBetweenX_2


		# 	print("space b/w x: " + str(spaceBetweenX))
			
		# 	n.sort()
		# 	highestX = n[-1]
		# 	lowestX = n[0]
		# 	print("highest X: " + str(highestX))
		# 	print("lowest X: " + str(lowestX))

		# 	totalXSpace = highestX - lowestX
		# 	# totalXSpace = index * spaceBetweenX
		# 	print("total X Space: " + str(totalXSpace))

		# 	# percentNotInfill = totalXSpace / spaceBetweenX
		# 	# percentInfill = totalXSpace / percentNotInfill
		# 	percentInfill = totalXSpace / spaceBetweenX
		# 	print("percent infill: " + str(percentInfill))
		# 	if percentInfill <= 100:
		# 		avgInfill.append(percentInfill)
			
		# 	print(index_)
		# 	# print(element)

		# # print(statistics.mean(avgInfill))
		# print("\n")

	def test500_110_infillMax(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.search(self.SLICER_MATTER_SLICE, gCodeInput)
		n = re.search(self.SLICER_SLIC3R, gCodeInput)

		if m != None:
			o = re.search(self.INFILL_HEADER1, gCodeInput)
			infill1 = float(o.group(1))
			if infill1 > self.MAX_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill1) + ") > value(" + str(self.MAX_INFILL_VAR) + ")"
			else: 
				actualResult = True
		elif n != None:
			p = re.search(self.INFILL_HEADER2, gCodeInput)
			infill2 = float(p.group(1))
			if infill2 > self.MAX_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill2) + ") > value(" + str(self.MAX_INFILL_VAR) + ")"
			else:
				actualResult = True
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"

		self.assertEqual(expectedResult, actualResult)

	def test500_120_infillMin(self):
		expectedResult = True
		actualResult = False
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.search(self.SLICER_MATTER_SLICE, gCodeInput)
		n = re.search(self.SLICER_SLIC3R, gCodeInput)

		if m != None:
			o = re.search(self.INFILL_HEADER1, gCodeInput)
			infill1 = float(o.group(1))
			print(infill1)
			if infill1 < self.MIN_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill1) + ") < value(" + str(self.MIN_INFILL_VAR) + ")"
			else: 
				actualResult = True
		elif n != None:
			p = re.search(self.INFILL_HEADER2, gCodeInput)
			infill2 = float(p.group(1))
			print(infill2)
			if infill2 < self.MIN_INFILL_VAR:
				actualResult = "Infill Error: value(" + str(infill2) + ") < value(" + str(self.MIN_INFILL_VAR) + ")"
			else:
				actualResult = True
		else:
			actualResult = "Unknown slicer. Unable to determine infill density"

		self.assertEqual(expectedResult, actualResult)

# if wrong type:fill continue and skip
# if type:fill: save to list
# if ; in line stop saving to list

	def test600_900_exceedsMaxXSize(self):
		expectedResult = False
		actualResult = True
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.findall(self.X_SIZE_HEADER, gCodeInput)
		elementX = None
		for index, element in enumerate(m):
			elementX = element
			if float(element) > self.MAX_X_SIZE:
				actualResult = " X value(" + str(elementX) + ") > X-axis bounds(" + str(self.MAX_X_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	CMB_MAX_X_SIZE = 200.0

	def test600_901_cmb_exceedsMaxXSize(self):
		expectedResult = False
		actualResult = True

		try:
			with open(self.GCODE_INPUT, 'rb') as f:
				gCodeInput = f.read().hex()
		except:
			self.skipTest("Not cmb file")
		
		index = 0
		thing = magic_number = machine_type = slice_height = ""
		part_volume = support_volume = num_of_str_chars1 = ""
		num_of_str_chars2 = part_material_str = ""
		support_material_str = part_min_X = part_min_Y = ""
		part_min_Z = part_max_X = part_max_Y = part_max_Z = ""

		temp = ""
		hexList = []
		for line in gCodeInput:
			for element in line:
				temp += element
				if (index + 1) % 2 == 0:
					hexList.append(temp)
					temp = ""
				index += 1

		for index, value in enumerate(hexList):
			# print(str(index) + ": " + str(value))

			if index >= 0 and index <= 3:
				magic_number += value
			elif index >= 4 and index <= 7:
				machine_type += value
			elif index >= 8 and index <= 11:
				slice_height += value
			elif index >= 12 and index <= 15:
				part_volume += value
			elif index >= 16 and index <= 19:
				support_volume += value
			elif index >= 20 and index <= 23:
				num_of_str_chars1 += value
			# elif index == 23:
			# 	num_of_str_chars = int(num_of_str_chars)
			elif index >= 24 and index <= 27:
				part_material_str += value
			elif index >= 28 and index <= 31:
				num_of_str_chars2 += value
			elif index >= 32 and index <= 37:
				support_material_str += value
			elif index >= 38 and index <= 41:
				part_min_X = value + part_min_X
			elif index >= 42 and index <= 45:
				part_min_Y = value + part_min_Y
			elif index >= 46 and index <= 49:
				part_min_Z = value + part_min_Z
			elif index >= 50 and index <= 53:
				part_max_X = value + part_max_X
			elif index >= 54 and index <= 57:
				part_max_Y = value + part_max_Y
			elif index >= 58 and index <= 61:
				part_max_Z = value + part_max_Z
			index += 1


		# print(magic_number)
			# print(machine_type)
			# print(slice_height)
			# print(part_volume)
			# print(support_volume)
			# print(num_of_str_chars1)
			# print(part_material_str)
			# print(num_of_str_chars2)
			# print(support_material_str)
			# print(part_min_X)
			# print(part_min_Y)
			# print(part_min_Z)
			# print(part_max_X)
			# print(part_max_Y)
			# print(part_max_Z)

		floatMaxX_in = ieeeConverter.hex2Float(part_max_X)
		floatMaxX_mm = floatMaxX_in / 0.0393700787
		if floatMaxX_mm > self.CMB_MAX_X_SIZE:
			actualResult = " X value(" + str(floatMaxX_mm) + ") < X-axis bounds(" + str(self.CMB_MAX_X_SIZE) + ")"
		else:
			actualResult = False

		self.assertEqual(expectedResult, actualResult)



	def test600_910_exceedsMinXSize(self):
		expectedResult = False
		actualResult = True
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.findall(self.X_SIZE_HEADER, gCodeInput)
		elementX = None
		for index, element in enumerate(m):
			elementX = element
			if float(element) < self.MIN_X_SIZE:
				if index == 0: continue
				actualResult = " X value(" + str(elementX) + ") < X-axis bounds(" + str(self.MIN_X_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	def test600_920_exceedsMaxYSize(self):
		expectedResult = False
		actualResult = True
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.findall(self.Y_SIZE_HEADER, gCodeInput)
		elementY = None
		for index, element in enumerate(m):
			elementY = element
			if float(element) > self.MAX_Y_SIZE:
				actualResult = " Y value(" + str(elementY) + ") > Y-axis bounds(" + str(self.MAX_Y_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	def test600_930_exceedsMinYSize(self):
		expectedResult = False
		actualResult = True
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.findall(self.Y_SIZE_HEADER, gCodeInput)
		elementY = None
		for index, element in enumerate(m):
			elementY = element
			if float(element) < self.MIN_Y_SIZE:
				if index == 0: continue
				actualResult = " Y value(" + str(elementY) + ") < Y-axis bounds(" + str(self.MIN_Y_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False
		self.assertEqual(expectedResult, actualResult)

	def test600_940_exceedsMaxZSize(self):
		expectedResult = False
		actualResult = True
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.findall(self.Z_SIZE_HEADER, gCodeInput)
		elementZ = None
		for index, element in enumerate(m):
			elementZ = element
			if float(element) > self.MAX_Z_SIZE:
				actualResult = "Z value(" + str(elementZ) + ") > Z-axis bounds(" + str(self.MAX_Z_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

	def test600_950_exceedsMinZSize(self):
		expectedResult = False
		actualResult = True
		try:
			with open(self.GCODE_INPUT, 'r') as f:
				gCodeInput = f.read()
		except:
			self.skipTest("Not G-Code file")

		m = re.findall(self.Z_SIZE_HEADER, gCodeInput)
		elementZ = None
		for index, element in enumerate(m):
			elementZ = element
			if float(element) < self.MIN_Z_SIZE:
				if index == 0: continue
				actualResult = "Z value(" + str(elementZ) + ") < Z-axis bounds(" + str(self.MIN_Z_SIZE) + ")"
				break
			elif index == len(m)-1:
				actualResult = False

		self.assertEqual(expectedResult, actualResult)

if __name__ == '__main__':
	if len(sys.argv) > 1:
		V3DPTestCases.GCODE_INPUT = sys.argv.pop()
		# print(V3DPTestCases.GCODE_INPUT)
	unittest.main()

